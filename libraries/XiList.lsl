/*
    XiList.lsl
    Library
    Xi LSL Framework
    Copyright (C) 2024  BuildTronics
    https://docs.buildtronics.net/xi-lsl-framework

    ╒══════════════════════════════════════════════════════════════════════════════╕
    │ LICENSE                                                                      │
    └──────────────────────────────────────────────────────────────────────────────┘

    This script is free software: you can redistribute it and/or modify it under the
    terms of the GNU Lesser General Public License as published by the Free Software
    Foundation, either version 3 of the License, or (at your option) any later
    version.

    This script is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License along
    with this script.  If not, see <https://www.gnu.org/licenses/>.

    ╒══════════════════════════════════════════════════════════════════════════════╕
    │ INSTRUCTIONS                                                                 │
    └──────────────────────────────────────────────────────────────────────────────┘

    TBD
*/

// ==
// == preprocessor options
// ==

#ifdef XIALL_ENABLE_XILOG_TRACE
#define XILIST_ENABLE_XILOG_TRACE
#endif

// ==
// == functions
// ==

string XiList_Elem(list var)
{
    if (var == []) return "[]";
    return "[\"" + llDumpList2String(var, "\", \"") + "\"]";
}

list XiList_Empty( // if a list only has one element that is a blank string, convert it to an empty list
    list in
    )
{
    if (llGetListLength(in) == 1)
    {
        if (llList2String(in, 0) == "") in = [];
    }
    return in;
}

list XiList_Collate(
    list a,
    list b
    )
{
    list out;
    integer i;
    integer l = llGetListLength(a);
    if (llGetListLength(b) > l) l = llGetListLength(b);
    for (i = 0; i < l; i++) out += llList2List(a, i, i) + llList2List(b, i, i);
    return out;
}

list XiList_Concatenate(
    string start,
    list a,
    string mid,
    list b,
    string end
    )
{
    list out;
    integer i;
    integer l = llGetListLength(a);
    if (llGetListLength(b) > l) l = llGetListLength(b);
    for (i = 0; i < l; i++) out += [start + llList2String(a, i) + mid + llList2String(b, i) + end];
    return out;
}

string XiList_ToString( // converts a list into a string without worrying about separators or JSON
    list in
    )
{
    string out;
    integer i;
    integer l = llGetListLength(in);
    string elem;
    for (i = 0; i < l; i++)
    {
        elem = llList2String(in, i);
        out += (string)llStringLength(elem) + "\n" + elem;
    }
    return out;
}

list XiList_FromStr( // converts a string generated by XiList_ToString(...) back into a list
    string in
    )
{
    list out;
    integer nl;
    string len;
    while (llStringLength(in))
    {
        nl = llSubStringIndex(in, "\n"); // get newline position, terminating element length
        len = llGetSubString(in, 0, nl - 1); // get element length
        if (len != "0" && (integer)len < 1) return []; // failed, length is not zero or a positive integer
        if (len == "0") out += [""]; // element is an empty string
        else out += [llGetSubString(in, nl + 1, nl + (integer)len)]; // add element text
        in = llDeleteSubString(in, 0, nl + (integer)len); // trim len, nl, and element from in string and try again
    }
    return out; // success, return list
}

integer XiList_FindPartial( // llListFindList but needle can be only part of the element instead of the entire element
    list x,
    string s
    )
{
    integer i;
    integer l = llGetListLength(x);
    for (i = 0; i < l; i++)
    {
        if (llSubStringIndex(llList2String(x, i), s) != -1) return i;
    }
    return -1;
}
