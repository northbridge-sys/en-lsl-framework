/*
enDate
Copyright (C) 2025  Northbridge Business Systems
https://docs.northbridgesys.com/en-framework
*/

/*!
Adds a number of milliseconds to an enDate millisec integer to safely wrap milliseconds at the ends of a month.
@param integer ms Millisec. See enDate_NowToMillisec() or enDate_TimestampToMillisec().
@param integer add Millisec to add. Limited to +/- 1530167295, otherwise you will silently overflow.
@return integer New millisec.
*/
integer enDate_AddMillisec(
    integer ms,
    integer add
)
{
    // check if adding takes us into the "dead zone" of 617316352 to 2147483647
    if ( ms + add > 617316352 ) return ( ms + add ) + 2764800000 * ( -1 * ( add > 0 ) ); // if we are adding +, subtract the entire range; otherwise, add it
    return ms + add; // no adjustment needed
}

/*!
Converts proportion of the 24 hours starting at midnight to an HMS list.
@param float p Daypart of 24 hours starting at midnight (0.0-1.0).
@return list [h, m, s].
*/
list enDate_DaypartToHMS(
    float p
)
{
    integer s = (integer)(86400 * p); // get total number of seconds in a day represented by this percentage
    integer h = s / 3600;
    integer m = (s / 60) % 60;
    s -= (h * 3600) + (m * 60);
    return [h, m, s];
}

/*!
Gets number of days in a specific month from year and month as integers.
@param integer y Year.
@param integer m Month.
@return integer Number of days in specified month.
*/
integer enDate_DaysInMonth(
    integer y,
    integer m
)
{
    if (m == 4 || m == 6 || m == 9 || m == 11) return 30;
    else if (m == 2)
    {
        if (y % 4 == 0) return 29;
        else return 28;
    }
    else return 31;
}

/*!
Gets number of days in a specific year as integer.
@param integer y Year.
@return integer Number of days in specified year.
*/
integer enDate_DaysInYear(
    integer y
)
{
    return 365 + ((!(y % 4) && y % 100) || !(y % 400));
}

/*!
Gets number of days in a specific month from YM list.
@param list ym [Y, M]. May include [D, h, m, s, u].
@return integer Number of days in specified month.
*/
integer enDate_DaysInYM(
    list ym
)
{
    return enDate_DaysInMonth(llList2Integer(ym, 0), llList2Integer(ym, 1));
}

/*!
Converts current environment time (sun position) at specified location to a proportion.
@param vector p Region-scope position.
@return float Daypart of 24 hours starting at midnight (0.0-1.0).
*/
float enDate_EnvironmentToDaypart(
    vector p
)
{
    list e = llGetEnvironment(p, [ENVIRONMENT_DAYINFO]);
    return (float)llList2String(e, 2) / (float)llList2String(e, 0);
}

/*!
Converts HM list to pretty string.
@param list hm [h, m]. May include [s, u]. Do not include [Y, M, D].
@param integer flags FLAG_ENDATE_* flags.
@return string Pretty string.
*/
string enDate_HMToPretty(
    list hm,
    integer flags
)
{
    hm = _enDate_HTo12(hm, flags);
    hm = _enDate_PadZeroesHMS(hm, flags);
    return llList2String(hm, 0) + ":" + llList2String(hm, 1) + llList2String(hm, -1);
}

/*!
Converts HMS list to pretty string.
@param list hms [h, m, s]. May include [u]. Do not include [Y, M, D].
@param integer flags FLAG_ENDATE_* flags.
@return string Pretty string.
*/
string enDate_HMSToPretty(
    list hms,
    integer flags
)
{
    hms = _enDate_HTo12(hms, flags);
    hms = _enDate_PadZeroesHMS(hms, flags);
    return llList2String(hms, 0) + ":" + llList2String(hms, 1) + ":" + llList2String(hms, 2) + xm;
}

/*!
Converts HMSU list to pretty string.
DOES NOT support FLAG_ENDATE_12_HOUR.
Should only be used for HMSU lists generated by interval times (e.g., a stopwatch).
@param list hmsu [h, m, s, u]. Do not include [Y, M, D].
@param integer flags FLAG_ENDATE_* flags.
@return string Pretty string.
*/
string enDate_HMSUToPretty(
    list hmsu,
    integer flags
)
{
    hmsu = _enDate_PadZeroesHMS(hmsu, flags);
    string o = llList2String(hmsu, 0) + ":" + llList2String(hmsu, 1) + ":" + llList2String(hmsu, 2) + _enDate_DecimalizeSubseconds((integer)llList2String(hmsu, 3), FALSE);
}

/*!
Function wrapper for _enDate_MToPretty() macro.
Can be called in multiple places with minimal memory impact.
This is used for optimization. If you only call enDate_MToPretty() once in the script, it's slightly more efficient to use the _enDate_MToPretty() macro directly.
@param integer month Month of year (1-12).
@return string Full textual representation of a month.
*/
string enDate_MToPretty(
    integer month
)
{
    return _enDate_MToPretty(month);
}

/*!
Converts a timestamp into an enDate millisec, an integer that can store a month's range of milliseconds.
enDate millisecs are not immediately related or aligned to any specific timeframe. They may only be compared with each other and modified using enDate functions.
@param string timestamp ISO 8601 timestamp from llGetTimestamp().
@return integer enDate millisec.
*/
integer enDate_TimestampToMillisec(
    string timestamp // llGetTimestamp string (use enDate_NowToMillisec() for the current value)
    )
{
    return 0x80000000 + // start at -2147483648
        (integer)llGetSubString( timestamp, 8, 9 ) * 86400000 + // days * ms_per_day (-2147483648 + (31 * 86400000) = 530916352)
        (integer)llGetSubString( timestamp, 11, 12 ) * 3600000 + // hours * ms_per_hour (530916352 + (23 * 3600000) = 613716352)
        (integer)llGetSubString( timestamp, 14, 15 ) * 60000 + // minutes * ms_per_minute (613716352 + (59 * 60000) = 617256352)
        (integer)( (float)llGetSubString( timestamp, 17, -2 ) * 1000.0 ); // seconds.ms * ms_per_second (617256352 + 60000 = 617316352)
    // total range is 2764800000 ms, or ms in 31 days
}

/*!
Converts ISO 8601 timestamp from llGetTimestamp() ("YYYY-MM-DDThh:mm:ss.ff..fZ") to [Y, M, D, h, m, s, µs].
Note that the enDate list format does not require µs (microseconds); this is the only function that returns it.
No validation is performed. All Z characters are removed, then the string is split into a list using all the possible separators.
Resultant enDate list DOES HAVE subsecond precision; other methods may not have subsecond precision. Round s if needed.
@param integer t ISO 8601 timestamp. See llGetTimestamp().
@return list [Y, M, D, h, m, s, u].
*/
list enDate_TimestampToYMDHMSU(
    string t
)
{
    // parse out all elements of timestamp
    list r = llParseStringKeepNulls(llReplaceSubString(t, "Z", "", 0), ["-", "T", ":"], []);

    // get seconds + subseconds
    float s = (float)llList2String(r, -1);

    // calculate microseconds, combine [Y, M, D, h, m] + [whole seconds, microseconds] as integers
    return enList_AllToInteger(llList2List(r, 0, 4) + [(integer)s, (integer)((s - (integer)s) * 1000000)]);
}

/*!
Converts Unix time into a full textual representation of the day of week.
Shamelessly stolen from Void Singer as CC0-licensed on LSL Wiki.
@param integer u Unix time. See llGetUnixTime().
@return string Full textual representation of the day of the week.
*/
string enDate_UnixToDOW(
    integer u
)
{
    return llList2String(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], enDate_UnixToIOW(u));
}

/*!
Converts Unix time into an index of week (IOW, 0-6 for each index of a weekday).
After considerable consideration (about 5 minutes of research), I've decided that IOWs are zero-indexed to Monday in accordance with ISO standards.
I am aware this is not the convention in the Americas, China, Japan, South Korea, and others. I don't really care.
@param integer u Unix time. See llGetUnixTime().
@return integer Index of week.
*/
integer enDate_UnixToIOW(
    integer u
)
{
    return (u % 604800 / 86400 + (u >> 31) + 4) % 7;
}

/*!
Converts Unix time to enDate list [Y, M, D, h, m, s].
DOES NOT have subsecond precision. All elements are integers.
@param integer u Unix time. See llGetUnixTime().
@return list [Y, M, D, h, m, s].
*/
list enDate_UnixToYMDHMS(
    integer u
)
{
    if (u / 2145916800) u = 2145916800 * (1 | u >> 31);

    integer y = 1970 + ((((u %= 126230400) >> 31) + u / 126230400) << 2);
    u -= 126230400 * (u >> 31);
    integer d = u / 86400;
    list r = [u % 86400 / 3600, u % 3600 / 60, u % 60];
 
    if (789 == d)
    {
        y += 2;
        u = 2;
        d = 29;
    }
    else
    {
        y += (d -= (d > 789)) / 365;
        d %= 365;
        d += u = 1;
        integer temp;
        while (d > (temp = (30 | (u & 1) ^ (u > 7)) - ((u == 2) << 1)))
        {
            ++u;
            d -= temp;
        }
    }
    return [y, u, d] + r;
}

/*!
Returns a diff interval between two YMDHMSU lists in seconds.
This requires that the ymdhmses be valid as Unix times for simplicity.
@param list ymdhms_a [Y, M, D, h, m, s] list.
@param list ymdhms_b [Y, M, D, h, m, s] list.
@return integer Seconds between two lists (ymdhms_a - ymdhms_b). If positive, ymdhms_a is later; if negative, ymdhms_b is later.
*/
integer enDate_YMDHMSDiffToSeconds(
    list ymdhms_a,
    list ymdhms_b
)
{
    return enDate_YMDHMSToUnix(ymdhms_a) - enDate_YMDHMSToUnix(ymdhms_b);
}

/*!
Converts YMDHMS list to pretty textual representation of a date.
@param list ymdhms [Y, M, D, h, m, s]. May include [u].
@param integer flags FLAG_ENDATE_* flags.
@return string Pretty date.
*/
string enDate_YMDHMSToPretty(
    list ymdhms,
    integer flags
)
{
    return enDate_YMDToPretty(llList2List(ymdhms, 0, 2), flags) + enDate_HMSToPretty(llList2List(ymdhms, 3, -1), flags);
}

/*!
Converts YMDHMS list to Unix time.
@param list ymdhms [Y, M, D, h, m, s].
@return integer Unix time. Comparable to llGetUnixTime().
*/
integer enDate_YMDHMSToUnix(
    list ymdhms
)
{
    integer y = llList2Integer(ymdhms, 0) - 1902;

    if (y >> 31 || y / 136) return 2145916800 * (1 | y >> 31);

    integer m = ~-llList2Integer(ymdhms, 1);
    integer d = ~-llList2Integer(ymdhms, 2);
    m += !~m;

    return 86400 * ((integer)(y * 365.25 + 0.25) - 24837 + m * 30 + (m - (m < 7) >> 1) + (m < 2) - (((y + 2) & 3) > 0) * (m > 1) + d + !~d)
        + llList2Integer(ymdhms, 3) * 3600
        + llList2Integer(ymdhms, 4) * 60 
        + llList2Integer(ymdhms, 5);
}

/*!
Converts YMDHMSU list to enDate millisec.
@param list ymdhmsu [Y, M, D, h, m, s, u].
@return integer enDate millisec.
*/
integer enDate_YMDHMSUToMillisec(
    list ymdhmsu
)
{
    return enDate_TimestampToMillisec(enDate_YMDHMSUToTimestamp(ymdhmsu));
}

/*!
Converts YMDHMSU list to ISO 8601 timestamp.
@param list ymdhmsu [Y, M, D, h, m, s, u].
@return string ISO 8601 timestamp.
*/
integer enDate_YMDHMSUToTimestamp(
    list ymdhmsu
)
{
    ymdhmsu = _enDate_PadZeroesIndex(ymdhmsu, 1, 2); // pad MM
    ymdhmsu = _enDate_PadZeroesIndex(ymdhmsu, 2, 2); // pad DD
    ymdhmsu = _enDate_PadZeroesIndex(ymdhmsu, 3, 2); // pad hh
    ymdhmsu = _enDate_PadZeroesIndex(ymdhmsu, 4, 2); // pad mm
    ymdhmsu = _enDate_PadZeroesIndex(ymdhmsu, 5, 2); // pad ss
    return
        llList2String(ymdhmsu, 0) // YYYY
        + "-" + llList2String(ymdhmsu, 1) // MM
        + "-" + llList2String(ymdhmsu, 2) // DD
        + "T" + llList2String(ymdhmsu, 3) // hh
        + ":" + llList2String(ymdhmsu, 4) // mm
        + ":" + llList2String(ymdhmsu, 5) // ss
        + _enDate_DecimalizeSubseconds((integer)llList2String(ymdhmsu, 6), TRUE) // .ff..f
        + "Z";
}

/*!
Converts YMD list to pretty textual representation of a date.
@param list ymd [Y, M, D]. May include [h, m, s, u].
@param integer flags FLAG_ENDATE_* flags.
@return string Pretty date.
*/
string enDate_YMDToPretty(
    list ymd,
    integer flags
)
{
    string m;
    string d;
    // generate month and day text if we're going to use it
    if (flags & (FLAG_ENDATE_TEXT_DMY | FLAG_ENDATE_TEXT_MDY))
    {
        // generate month
        if (flags & FLAG_ENDATE_TEXT_SHORT)
        { // we need a short month ("Jan")
            m = enDate_MToPrettyShort(llList2Integer(ymd, 1));
            if (flags & FLAG_ENDATE_TEXT_SHORT_DOT) m += "."; // we need to add a dot ("Jan.")
        }
        else m = enDate_MToPretty(llList2Integer(ymd, 1)); // we need a full month ("January")

        // generate day
        integer i_d = llList2Integer(ymd, 2);
        d = (integer)d; // start with raw digit ("1")
        if (flags & FLAG_ENDATE_TEXT_ORDINAL) d += enInteger_Ordinal(i_d); // we need to add an ordinal ("1st")
        if (flags & (FLAG_ENDATE_TEXT_DMY | FLAG_ENDATE_TEXT_OF)) d += " of";
    }

    // textual representation of date in DD Mmm YYYY
    if (flags & FLAG_ENDATE_TEXT_DMY)
        return d + " " + m + " " + llList2Integer(ymd, 0);

    // textual representation of date in Mmm DD, YYYY
    if (flags & FLAG_ENDATE_TEXT_MDY)
        return m + " " + d + ", " + llList2Integer(ymd, 0);
}

string _enDate_DecimalizeSubseconds(
    integer u,
    integer force
)
{
    string ss = (string)(u * 0.000001); // subseconds - note we do NOT validate if subseconds are <1.0 second!
    integer i = llSubStringIndex(ss, ".");
    if (i == -1)
    { // subseconds DOES NOT have a decimal
        if (force) return "0.0";
        return "";
    }
    return llDeleteSubString(ss, 0, i - 1); // subseconds DOES have a decimal, return only decimal and following digits
}

/*!
Internal function to convert H* list to 12-hour format, and append an "A"/"P" depending on the hour (may be modified depending on flags used).
@param list h [h]. May include [m, s, u]. Do not include [Y, M, D].
@param integer flags FLAG_ENDATE_12_HOUR* flags.
@return list Same list as sent in as a parameter, with hours potentially changed and an A/P element added to end.
*/
list _enDate_HTo12(
    list h,
    integer flags
)
{
    string xm;
    if (flags & FLAG_ENDATE_12_HOUR)
    {
        xm = "A";
        integer ih = (integer)llList2String(h, 0);
        if (ih == 0) ih = 12;
        else
        {
            if (ih >= 12) xm = "P"; // if hour 12-23, P
            if (ih > 12) ih -= 12; // if hour 13-23, go back to 1-11
        }
        if (flags & FLAG_ENDATE_12_HOUR_M) xm += "M";
        if (flags & FLAG_ENDATE_12_HOUR_SPACE) xm = " " + xm;
        h = llListReplaceList(h, [(integer)llList2String(h, 0) - 12], 0, 0);
    }
    return h + [xm];
}

/*!
Internal function to pad an HMS(U) list with zeroes depending on specified flags.
@param list hms [h, m, s]. May include [u]. May NOT include [Y, M, D].
@param integer flags FLAG_ENDATE_PAD_ZEROES_* flags. May include other flags.
@return list [h, m, s] with leading zero padding as requested.
*/
list _enDate_PadZeroesHMS(
    list hms,
    integer flags
)
{
    if (flags & FLAG_ENDATE_PAD_ZEROES_HOURS) hms = _enDate_PadZeroesIndex(hms, 0, 2);
    if (flags & FLAG_ENDATE_PAD_ZEROES_MINUTES) hms = _enDate_PadZeroesIndex(hms, 1, 2);
    if (flags & FLAG_ENDATE_PAD_ZEROES_SECONDS) hms = _enDate_PadZeroesIndex(hms, 2, 2);
    return hms;
}

/*!
Internal function to pad an element of a list with zeroes.
@param list l Any list.
@param integer i Index in list.
@param integer d Digits to pad to.
@return list Resulting list.
*/
list _enDate_PadZeroesIndex(
    list l,
    integer i, // index in list
    integer d // digits
)
{
    while (llStringLength(llList2String(l, i)) < d) l = llListReplaceList(l, ["0" + llList2String(l, i)], i, i);
    return l;
}
